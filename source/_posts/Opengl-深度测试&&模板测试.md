---
layout: post
categories: opengl
title: 'Opengl-深度测试&&模板测试'
date: 2018-08-28
---

> ###深度测试

**深度缓冲**：用来存储深度信息的，可以这么理解，在你屏幕上最后留下的裁剪区域你看到的东西其实是有深度的，就像现实世界里一样，有远近这样。然后这个远近的程度信息就存储在了深度缓冲里

**深度测试**：当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

**怎么测试**：
GL_ALWAYS	永远通过深度测试
GL_NEVER	永远不通过深度测试
GL_LESS	在片段深度值小于缓冲的深度值时通过测试
GL_EQUAL	在片段深度值等于缓冲区的深度值时通过测试
GL_LEQUAL	在片段深度值小于等于缓冲区的深度值时通过测试
GL_GREATER	在片段深度值大于缓冲区的深度值时通过测试
GL_NOTEQUAL	在片段深度值不等于缓冲区的深度值时通过测试
GL_GEQUAL	在片段深度值大于等于缓冲区的深度值时通过测试

**使用方法**：
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_LESS);

也就是说我们通过glDepthFunc设置了测试方法后，opengl会根据我们设置的来决定测试是否通过。

**测试的是什么呢？**
其实就是测试的两个片段或者你可以理解为两个像素点在一个位置，一个点处的深度值。通过了，这个像素点的片段就是新的，通不过这个新的就被抛弃。

举个例子：

渲染流程：先渲染一个正方体盒子，后渲染地板，

这张图是glDepthFunc(GL_ALWAYS);的情况下的显示
![这里写图片描述](/images/opengl/depthstenciltest1.png)

这张图是glDepthFunc(GL_LESS);的情况下的显示
![这里写图片描述](/images/opengl/depthstenciltest2.png)

可以看出来，always下因为一直通过测试，这样新的片段比如地板就会通过测试在同一位置上显示的就是地板了。。所以才会出现那样的现象。虽然我们的顶点数据上地板在后面立方体盒子在上面。但是因为深度测试的原因才会出现如此结果。

**总结**：**深度测试就是用来对比深度（距离相机远度）然后决定片段像素用前面绘制的还是用新绘制的**


----------


> ###模板测试

**模板缓冲**：和深度缓冲一样，其实基本上和所有缓冲都一样，顾名思义是用来存放东西，只不过这次这里存放的是一个模板值。你可以想象理解为这里存放了一个值就好

**模板测试**：同样和深度测试一样，模板测试的目的也是为了决定片段的取舍，也就是说，我们在模板测试阶段要根据一个规则利用模板缓冲存的的值来决定前面的片段和后面的片段保留哪个

**测试方法**：
GL_KEEP	保持当前储存的模板值
GL_ZERO	将模板值设置为0
GL_REPLACE	将模板值设置为glStencilFunc函数设置的ref值
GL_INCR	如果模板值小于最大值则将模板值加1
GL_INCR_WRAP	与GL_INCR一样，但如果模板值超过了最大值则归零
GL_DECR	如果模板值大于最小值则将模板值减1
GL_DECR_WRAP	与GL_DECR一样，但如果模板值小于0则将其设置为最大值
GL_INVERT	按位翻转当前的模板缓冲值

glStencilFunc(GL_EQUAL, 1, 0xFF);  // 测试规则
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); //决定如何更新缓冲


**使用方法**：
glEnable(GL_STENCIL_TEST);
glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样
glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）

例子如下：
![这里写图片描述](/images/opengl/depthstenciltest3.png)

总结：**模板测试就是用来决定模板缓冲中的值是什么比较规则，然后根据这个规则来取舍一个位置点下的片段的取舍的**。


----------
**核心：无论是深度测试还是模板测试，都是来决定是否抛弃或者是否使用片段像素点颜色的**

好长时间了，突然碰到一个朋友在做裁剪的问题，也用到了模板缓冲这个理念和功能，然后又加深了一下理解这里记录下。

其实，上面总结的核心 决定是否抛弃或者使用片段像素点颜色 这个很精确，但是有时候很不好理解，举个例子：

    glStencilFunc(GL_ALWAYS, 1, 0xFF); // 所有的片段都应该更新模板缓冲
    glStencilMask(0xFF); // 启用模板缓冲写入
   
   想象一下，一个四方形(我们的屏幕）无数像素点(片段）启用缓冲的，现在只要绘制那么这个缓冲就会被写入了对吧？这个时候被绘制的像素点的位置缓冲其实就是1，这里是1。
 

    glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
    glStencilMask(0x00); // 禁止模板缓冲的写入

我们将模板函数设置为GL_NOTEQUAL，它会保证我们只绘制模板值不为1的部分，也就是核心说的：这次绘制这次操作，只有模板值不为1的部分保留其他的像素点上的片段颜色全部抛弃，是不是很好懂？
再次看下这张图
![这里写图片描述](/images/opengl/depthstenciltest3.png)
补充一下colorbuffer也就是经过frag片段着色后的一块缓冲区和深度测试缓冲区，裁剪测试缓冲区，以及帧缓冲区都是一个核心概念，就是一块存放内容的内存而已。
继续说，我们将模板函数设置为GL_NOTEQUAL那么这句就决定了一件事要清楚的认识到，我们这次操作这次的绘制只会保留不等于1的部分，记住了是我们这次完整的draw操作(通过shaderuse之后）这次的片段出来到我们的模板测试这（如果我们开启了模板测试）那么这次的所有像素点只会保留位置在模板缓冲中不等于1的部分其他的部分不会绘制，也就是之前1的部分是啥还是啥，现在只有1以外的部分会被我们绘制上东西。明白了吧？
再次强调下：glStencilMask(0x00); // 禁止模板缓冲的写入 是为了不让写缓存 就是现在啥样就用啥样的模板测试来对比，这样不就没有干扰了么，因为没有新的东西干扰写入，就用当前的模板缓冲上的值来对比

PS:补充一些概念再
在OpenGL中存在着多种缓冲区，这些缓冲区大致分为：
* 颜色缓冲区：用于绘图的缓冲区，它包含了颜色索引或者RGBA颜色数据。
* 深度缓冲区：存储每个像素的深度值，当启动深度测试时，片段像素深度值和深度缓冲区深度值进行比较，决定片段哪些像素点数据可以替换到颜色缓冲区中。
* 模板缓冲区(Stencil Buffer)：与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。模板测试发生在透明度测试（alpha test）之后，深度测试（depth test）之前。如果模板测试通过，则相应的像素点更新，否则不更新。就像使用纸板和喷漆一样精确的混图一样，当启动模板测试时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。下图描述了模板缓冲区的原理

