---
layout: post
categories: opengl
title: 'Opengl-基本概念-转换矩阵&&坐标系（最难理解的两章）'
date: 2018-08-20
---

> ##前言
  
  可能这是Opengl学习的时候最难理解的地方，很多人也因为这个地方放弃了。但是我觉得，我们可以不明白有些矩阵是如何推到出来的，但是我们要明白一些简单的矩阵为什么可以做到从一个坐标系到另一个坐标系的转换。

> 向量

  向量就是一个有方向的线段，这貌似是我们中学就知道的概念，你可以把向量想像成一个藏宝图上的指示：“向左走10步，向北走3步，然后向右走5步”；“左”就是方向，“10步”就是向量的长度。那么这个藏宝图的指示一共有3个向量。
  ![这里写图片描述](/images/opengl/transform1.png)
  看图应该更容易理解，我们也一般把向量用->这种符号在字母上面结合来表示。
  **为什么说向量？假如我们有一个三维向量(1,1,1) 我们可以想象的到它在空间中的样子，然而我们要描述空间中的一点是不是也正好就是这么巧的碰到了一起？是不是？假设有点在(3,2,1)我们是不是就可以在原点发射一条射线指向这个点？然后这个线段+方向就是向量。更合适的是我们从原点发出的，那么这个向量w也正好就是我们想要表示的点了。**
  

> 向量加减

![这里写图片描述](/images/opengl/transform2.png)

> 向量相乘

 两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是**点乘(Dot Product)**，记作v¯⋅k¯，另一个是**叉乘(Cross Product)**，记作v¯×k¯。
 * 点乘：v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ  如果v和k都是单位向量那么v¯⋅k¯=cosθ
 * 叉乘：叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。
![这里写图片描述](/images/opengl/transform3.png)
上面的这个向量的运算都是一些基本的复习，大家应该可以轻松的理解了，不要钻牛角尖，就像1+1为啥等于2一样，这些公式都是前人的成果好好珍惜。

> 矩阵

![这里写图片描述](/images/opengl/transform4.png)
  * 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。
  * 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。
  ![这里写图片描述](/images/opengl/transform5.png)
  矩阵的乘法是一系列乘法和加法组合的结果，它使用到了左侧矩阵的行和右侧矩阵的列。


----------
重点来了，为什么上面说了那么多，向量也好，矩阵也好？为啥？我们为啥复习这些有啥用？就是为了下面的讲述为什么矩阵可以表示变换，注意了。重点来了。


----------
![这里写图片描述](/images/opengl/transform6.png)
我们用一个单位矩阵乘以一个矩阵。发现了什么？发现了什么？结果不变啊老哥。有了这个我们就可以继续进行了

> 缩放
 
   ![这里写图片描述](/images/opengl/transform7.png)
   看出来了么？我们通过上面复习的矩阵乘法，然后计算出来的结果就是如图显示的，结果，我们的xyz都被乘以了S1，S2，S3也就是 我们这个向量经过了缩放，理解了么？有么有醍醐灌顶？原来难以理解为啥矩阵可以变换是不是理解了？就是这样顺理成章的，就是我们用的普通的公式完成了一次缩放操作

> 位移

  ![这里写图片描述](/images/opengl/transform8.png)
  同理我们也就更容易理解位移了吧？我们通过这样一个矩阵乘上(x,y,z,1)这么个矩阵的出来的结果如图所示，我们就相当于对这个同样数据元素的向量进行了一次位移。有没有？是不是很简单？

> 旋转

  兄弟说实话，这个也是被前人推到出来的矩阵，然而我不会推到过程。。。真的不会，但是你要明白。。是有这么个矩阵就像上面的S也好T也好乘上我们的矩阵来实现渲

> 矩阵的组合

  其实我们说了这半天，先从向量说，又说了矩阵，然后通过单位矩阵推到出了位移渲染和肯定存在的旋转。为了什么？就是为了让我们的渲染出来的东西可以动，对就是可以动。
  


----------


----------

> ##下面我们说一下坐标系

* 局部空间(Local Space，或者称为物体空间(Object Space))
* 世界空间(World Space)
* 观察空间(View Space，或者称为视觉空间(Eye Space))
* 裁剪空间(Clip Space)
* 屏幕空间(Screen Space)

上面这些概念大概所有的Opengl教程都会说。这里不做累述。我们这里要做一个理解，为什么要有这些坐标系？为什么一个坐标系不够搞这么多干嘛？不烦吗？然后这些坐标系给我们带来了什么好处。

首先，我们暂停下来，在脑海中想想一下，空空的一个世界中，有一个立方体，或者任何其他你感兴趣的模型或者东西。okay想好了吧？接着，我们假如想在立方体上贴一个小星星的图片，我们怎么做？肯定得知道要贴在立方体的什么位置上吧？这个时候如果我们站在世界里的其他一点上怎么描述似乎都不恰当，但是，如果我们这么说：“立方体的(x,y,z)处贴个星星” 这句话你没有多想，你也会很自然的把它放到一个坐标系里，然后中心是原点。然后你找到了这个点贴了个星星，对吧？为什么这么想？就是因为你它放在了它的本地坐标系下你更好定位一些位置。然后我们接着想，如果空空的世界里有两个立方体，这个时候要是有人让你在右边的立方体上贴个星星，你怎么做？你如果还在刚才的本地坐标系里这个时候你对不上了，但是你听到这句话后你会很自然的站在了世界原点这么一个坐标系里，看这两个立方体，然后找到了右边的贴上了星星，为什么做？为什么又很自然的做了？因为这就是方便，很符合人理解的角度上的做法。说了这两个想象例子，你是不是稍微明白了什么，不是我们非得增加一个坐标系或者这么多坐标系，而是增加了这些坐标系后，我们更能很好的理解很好的处理。同理，观察空间以及裁剪空间，屏幕空间，都是为了做更方便更合适的处理才出现的。引用书上的一句话“**在这些特定的坐标系统中，一些操作或运算更加方便和容易**”

![这里写图片描述](/images/opengl/transform9.png)

然后我们是如何让物体从一个坐标系变换到另一个坐标系的呢？这就要看我们上面说的矩阵变化 位移 缩放 旋转了。 你可以很简单的想象，如果一个物体在那，我们咱们挪动或者旋转摆放肯定才能把它放到世界空间中想放的位置吧？这就是通过Model矩阵来做的一次乘法运算同理后面的一样。

集合起所有矩阵来就是：
![这里写图片描述](/images/opengl/transform10.png)
注意了，虽然是从左往右写的，但是运算其实是从右往左依次进行的。


----------
理解了么？最难的地方其实是你钻了牛角尖，然而这里帮助大家简单的理解推到出矩阵乘以你的坐标（这里只不过用了一列举证来表示相同的数据元素）可以让你的坐标变化，然后我们讲了下很多坐标系，而为什么有这么多也是为了在不同的坐标系下方便我们操作计算理解而已。就是酱紫
